
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_containers_sparse_map.hpp:

Program Listing for File sparse_map.hpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_containers_sparse_map.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/containers/sparse_map.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <vector>
   #include <unordered_map>
   #include <type_traits>
   #include <algorithm>
   #include <stdexcept>
   #include <core/platform/platform.hpp>
   #include <core/types/primitives.hpp>
   #include <core/containers/iterator_tricks.hpp>
   
   #include <Optick/optick.h>
   
   namespace legion::core
   {
       template <typename key_type, typename value_type, template<typename...> typename dense_type = std::vector, template<typename...> typename sparse_type = std::unordered_map>
       class sparse_map
       {
       public:
           using self_type = sparse_map<key_type, value_type, dense_type, sparse_type>;
           using self_reference = self_type&;
           using self_const_reference = const self_type&;
   
           using key_reference = key_type&;
           using key_const_reference = const key_type&;
           using key_pointer = key_type*;
   
           using value_reference = value_type&;
           using value_const_reference = const value_type&;
           using value_pointer = value_type*;
   
           using sparse_container = sparse_type<key_type, size_type>;
           using dense_value_container = dense_type<value_type>;
           using dense_key_container = dense_type<key_type>;
   
           using iterator = core::key_value_pair_iterator<typename dense_key_container::iterator, typename dense_value_container::iterator>;
           using const_iterator = core::key_value_pair_iterator<typename dense_key_container::const_iterator, typename dense_value_container::const_iterator>;
   
       private:
           dense_value_container m_dense_value;
           dense_key_container m_dense_key;
           sparse_container m_sparse;
   
           size_type m_size = 0;
           size_type m_capacity = 0;
   
       public:
           L_NODISCARD dense_value_container& values() noexcept { return m_dense_value; }
           L_NODISCARD const dense_value_container& values() const noexcept { return m_dense_value; }
   
           L_NODISCARD dense_key_container& keys() noexcept { return m_dense_key; }
           L_NODISCARD const dense_key_container& keys() const noexcept { return m_dense_key; }
   
           L_NODISCARD iterator begin() noexcept { return iterator(m_dense_key.begin(), m_dense_value.begin()); }
           L_NODISCARD const_iterator begin() const noexcept { return const_iterator(m_dense_key.cbegin(), m_dense_value.cbegin()); }
           L_NODISCARD const_iterator cbegin() const noexcept { return const_iterator(m_dense_key.cbegin(), m_dense_value.cbegin()); }
   
           L_NODISCARD iterator end() noexcept { return iterator(m_dense_key.begin() + m_size, m_dense_value.begin() + m_size); }
           L_NODISCARD const_iterator end() const noexcept { return const_iterator(m_dense_key.cbegin() + m_size, m_dense_value.cbegin() + m_size); }
           L_NODISCARD const_iterator cend() const noexcept { return const_iterator(m_dense_key.cbegin() + m_size, m_dense_value.cbegin() + m_size); }
   
           L_NODISCARD size_type size() const noexcept { return m_size; }
   
           L_NODISCARD size_type capacity() const noexcept { return m_capacity; }
   
           L_NODISCARD size_type max_size() const noexcept { return m_dense_value.max_size(); }
   
           L_NODISCARD bool empty() const noexcept { return m_size == 0; }
   
           void clear() noexcept { m_size = 0; }
   
           void reserve(size_type size)
           {
               OPTICK_EVENT();
               if (size > m_capacity)
               {
                   m_dense_value.resize(size);
                   m_dense_key.resize(size);
                   m_capacity = size;
               }
           }
   
   #pragma region count
   
           L_NODISCARD size_type count(key_const_reference key) const
           {
               OPTICK_EVENT();
               return contains(key);
           }
   
           L_NODISCARD size_type count(key_type&& key) const
           {
               OPTICK_EVENT();
               return contains(key);
           }
   #pragma endregion
   
   #pragma region contains
   
           L_NODISCARD bool contains(key_const_reference key) const
           {
               OPTICK_EVENT();
               if (!m_sparse.count(key))
                   return false;
   
               const size_type& sparseval = m_sparse.at(key);
               return sparseval >= 0 && sparseval < m_dense_key.size() && sparseval < m_size && m_dense_key.at(sparseval) == key;
           }
   
           L_NODISCARD bool contains(key_type&& key) const
           {
               OPTICK_EVENT();
               if (!m_sparse.count(key))
                   return false;
               
               const size_type& sparseval = m_sparse.at(key);
               return sparseval >= 0 && sparseval < m_dense_key.size() && sparseval < m_size && m_dense_key.at(sparseval) == key;
           }
   
           template<typename T>
           L_NODISCARD bool contains(const sparse_map<key_type, T>& other) const
           {
               OPTICK_EVENT();
               if (other.m_size == 0)
                   return true;
   
               if (m_size == 0 || m_size < other.m_size)
                   return false;
   
               for (int i = 0; i < other.m_size; i++)
                   if (!contains(other.m_dense_key.at(i)))
                       return false;
   
               return true;
           }
   #pragma endregion
   
           L_NODISCARD bool equals(self_const_reference other) const
           {
               OPTICK_EVENT();
               if (m_size == other.m_size)
               {
                   for (int i = 0; i < m_size; i++)
                       if (!(other.contains(m_dense_key.at(i)) && get(m_dense_key.at(i)) == other.get(m_dense_key.at(i))))
                           return false;
   
                   return true;
               }
   
               return false;
           }
   
           L_NODISCARD bool operator==(self_const_reference other) const
           {
               OPTICK_EVENT();
               if (m_size == other.m_size)
               {
                   for (int i = 0; i < m_size; i++)
                       if (!(other.contains(m_dense_key.at(i)) && get(m_dense_key.at(i)) == other.get(m_dense_key.at(i))))
                           return false;
   
                   return true;
               }
   
               return false;
           }
   
   #pragma region find
   
           L_NODISCARD iterator find(value_const_reference val)
           {
               OPTICK_EVENT();
               return std::find(begin(), end(), val);
           }
   
           L_NODISCARD const_iterator find(value_const_reference val) const
           {
               OPTICK_EVENT();
               return std::find(begin(), end(), val);
           }
   #pragma endregion
   
   #pragma region insert
   
           std::pair<iterator, bool> insert(key_const_reference key, value_const_reference val)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           std::pair<iterator, bool> insert(key_type&& key, value_const_reference val)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = std::move(key);
   
                   m_sparse[*itr_key] = m_size;
                   ++m_size;
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           std::pair<iterator, bool> insert(key_const_reference key, value_type&& val)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = std::move(val);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           std::pair<iterator, bool> insert(key_type&& key, value_type&& val)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = std::move(val);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = std::move(key);
   
                   m_sparse[*itr_key] = m_size;
                   ++m_size;
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region emplace
   
           template<typename... Arguments>
           std::pair<iterator, bool> emplace(key_const_reference key, Arguments&&... arguments)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   
           template<typename... Arguments>
           std::pair<iterator, bool> emplace(key_type&& key, Arguments&&... arguments)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = std::move(key);
   
                   m_sparse[*itr_key] = m_size;
                   ++m_size;
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region operator[]
   
           value_reference operator[](key_type&& key)
           {
               OPTICK_EVENT();
               key_type k;
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type();
   
                   auto itr_key = m_dense_key.begin() + m_size; // Find iterator location at which to store the key.
                   *itr_key = std::move(key); // Move the key into the location.
                   k = *itr_key; // Fetch a copy of the key for reuse in the rest of the function.
                   m_sparse[k] = m_size;
                   ++m_size;
               }
               else
                   k = key;
   
               return m_dense_value.at(m_sparse.at(k));
           }
   
           value_reference operator[](key_const_reference key)
           {
               OPTICK_EVENT();
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type();
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
               }
   
               return m_dense_value.at(m_sparse.at(key));
           }
   
           value_const_reference operator[](key_type&& key) const
           {
               OPTICK_EVENT();
   #ifdef LGN_SAFE_MODE
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   #endif
   
               return m_dense_value.at(m_sparse.at(key));
           }
   
           value_const_reference operator[](key_const_reference key) const
           {
               OPTICK_EVENT();
   #ifdef LGN_SAFE_MODE
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   #endif
   
               return m_dense_value.at(m_sparse.at(key));
           }
   #pragma endregion
   
   #pragma region at
   
           inline value_reference at(key_type&& key)
           {
               OPTICK_EVENT();
               return m_dense_value.at(m_sparse.at(key));
           }
   
           inline value_reference at(key_const_reference key)
           {
               OPTICK_EVENT();
               return m_dense_value.at(m_sparse.at(key));
           }
   
           inline value_const_reference at(key_type&& key) const
           {
               OPTICK_EVENT();
               return m_dense_value.at(m_sparse.at(key));
           }
   
           inline value_const_reference at(key_const_reference key) const
           {
               OPTICK_EVENT();
               return m_dense_value.at(m_sparse.at(key));
           }
   #pragma endregion
   
           size_type erase(key_const_reference key)
           {
               OPTICK_EVENT();
               if (contains(key))
               {
                   if (m_size - 1 != m_sparse.at(key))
                   {
                       m_dense_value.at(m_sparse.at(key)) = std::move(m_dense_value.at(m_size - 1));
                       m_dense_key.at(m_sparse.at(key)) = std::move(m_dense_key.at(m_size - 1));
                       m_sparse.at(m_dense_key.at(m_size - 1)) = std::move(m_sparse.at(key));
                   }
                   --m_size;
                   --m_capacity;
                   m_dense_value.resize(m_size);
                   m_dense_key.resize(m_size);
                   return true;
               }
               return false;
           }
       };
   }

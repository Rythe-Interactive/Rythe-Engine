
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_compute_context.hpp:

Program Listing for File context.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_compute_context.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/compute/context.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <core/compute/program.hpp> // Kernel, Buffer
   #include <core/filesystem/resource.hpp> // basic_resource
   #include <utility>
   #include <core/data/image.hpp>
   
   #include <Optick/optick.h>
   
   namespace legion::core::compute {
   
   
   class Context
   {
   public:
   
       static void init();
   
       static bool initialized();
   
       static Program createProgram(const filesystem::basic_resource& resource);
   
   
       template <class T>
       static Buffer createBuffer(std::vector<T>& container,buffer_type type,std::string name = "")
       {
           OPTICK_EVENT();
           return Buffer(
               m_context,
               reinterpret_cast<byte*>(container.data()), // data as void-ptr
               container.size() * sizeof( T ),  // size with data as void-ptr
               type,
               std::forward<std::string>(name)
           );
       }
   
       static Buffer createBuffer(byte* data, size_type size, buffer_type type, std::string name = "")
       {
           OPTICK_EVENT();
           return Buffer(m_context,data,size,type,std::forward<std::string>(name));
       }
   
       static Buffer createImage(image& img,buffer_type type, std::string name ="")
       {
           OPTICK_EVENT();
           size_type width = img.size.x;
           size_type height = img.size.y;
           size_type depth = 0;
   
           cl_image_format fmt;
   
           switch(img.format){
           case channel_format::eight_bit: fmt.image_channel_data_type = CL_UNORM_INT8; break;
           case channel_format::sixteen_bit: fmt.image_channel_data_type = CL_UNORM_INT16; break;
           case channel_format::float_hdr: fmt.image_channel_data_type = CL_FLOAT;break;
           default:
               {
                   log::warn("Buffer::createImage invalid Image format!");
                   fmt.image_channel_data_type = CL_UNORM_INT8;
               }
           }
   
           switch(img.components)
           {
           case image_components::grey: fmt.image_channel_order = CL_R; break;
           case image_components::grey_alpha: fmt.image_channel_order = CL_RA; break;
           case image_components::rgb: fmt.image_channel_order = CL_RGB; break;
           case image_components::rgba: fmt.image_channel_order = CL_RGBA; break;
           default:
               {
                   log::warn("Buffer::createImage invalid Image Components!");
                   fmt.image_channel_order = CL_RGBA; 
               }
           }
   
           return Buffer(m_context,img.get_raw_data<byte>(),width,height,depth,CL_MEM_OBJECT_IMAGE2D,&fmt,type,name);
       }
   
       static Buffer createImageFromOpenGLImage(uint target,uint texture,buffer_type type, std::string name ="",uint mip_level = 0)
       {
           OPTICK_EVENT();
           return Buffer(m_context,target,texture,mip_level,type, std::move(name));
       }
   
       static Buffer createImageFromOpenGLBuffer(uint bufferid,buffer_type type, std::string name ="")
       {
           OPTICK_EVENT();
           return Buffer(m_context,bufferid,type,false, std::move(name));
       }
       static Buffer createImageFromOpenGLRenderBuffer(uint bufferid,buffer_type type, std::string name ="")
       {
           OPTICK_EVENT();
           return Buffer(m_context,bufferid,type,true, std::move(name));
       }
   
   
       static cl_device_id getDeviceId()
       {
           return m_device_id;
       }
   
   private:
   
       static bool m_initialized;
       static cl_context m_context;
       static cl_platform_id m_platform_id;
       static cl_device_id m_device_id;
   };
   }

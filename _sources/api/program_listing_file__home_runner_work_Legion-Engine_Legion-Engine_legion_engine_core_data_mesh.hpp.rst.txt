
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_data_mesh.hpp:

Program Listing for File mesh.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_data_mesh.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/data/mesh.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/types/primitives.hpp>
   #include <core/math/math.hpp>
   #include <core/filesystem/resource.hpp>
   #include <core/filesystem/view.hpp>
   #include <core/async/rw_spinlock.hpp>
   #include <core/data/image.hpp>
   
   #include <utility>
   #include <vector>
   #include <unordered_map>
   #include <memory>
   #include <functional>
   
   namespace legion::core
   {
       struct sub_mesh
       {
           std::string name;
           size_type indexCount;
           size_type indexOffset;
       };
   
       struct mesh
       {
           std::string filePath;
           std::vector<math::vec3> vertices;
           std::vector<math::color> colors;
           std::vector<math::vec3> normals;
           std::vector<math::vec2> uvs;
           std::vector<math::vec3> tangents;
           std::vector<uint> indices;
   
           std::vector<sub_mesh> submeshes;
   
           static void to_resource(filesystem::basic_resource* resource, const mesh& value);
   
           static void from_resource(mesh* value, const filesystem::basic_resource& resource);
   
           static void calculate_tangents(mesh* data);
       };
   
       struct mesh_handle
       {
           id_type id = invalid_id;
   
           std::pair<async::rw_spinlock&, mesh&> get();
   
           bool operator==(const mesh_handle& other) const { return id == other.id; }
           operator id_type() { return id; }
       };
   
       constexpr mesh_handle invalid_mesh_handle{ invalid_id };
   
       struct material_data
       {
           std::string name;
   
           bool opaque;
           float alphaCutoff;
           bool doubleSided;
   
           math::color albedoValue;
           image_handle albedoMap;
           float metallicValue;
           image_handle metallicMap;
           float roughnessValue;
           image_handle roughnessMap;
           image_handle metallicRoughnessMap;
           math::color emissiveValue;
           image_handle emissiveMap;
   
           image_handle normalMap;
           image_handle aoMap;
           image_handle heightMap;
       };
   
       using material_list = std::vector<material_data>;
   
       struct mesh_import_settings
       {
           material_list* materials = nullptr;
           bool triangulate = true;
           bool vertex_color = false;
           filesystem::view contextFolder = filesystem::view(std::string_view(""));
       };
   
       const mesh_import_settings default_mesh_settings{ nullptr, true, false, filesystem::view(std::string_view("")) };
   
       class MeshCache
       {
           friend struct mesh_handle;
       private:
           static std::unordered_map<id_type, std::unique_ptr<std::pair<async::rw_spinlock, mesh>>> m_meshes;
           static std::unordered_map<id_type, filesystem::view> m_materialsToDigest;
           static async::rw_spinlock m_meshesLock;
       public:
           static id_type debugId;
   
           static mesh_handle create_mesh(const std::string& name, const filesystem::view& file, mesh_import_settings settings = default_mesh_settings);
   
           static mesh_handle create_mesh(const std::string& name, const mesh& mesh);
   
           static mesh_handle copy_mesh(const std::string& name, const std::string& newName);
   
           static mesh_handle copy_mesh(id_type id, const std::string& newName);
   
           static mesh_handle get_handle(const std::string& name);
   
           static mesh_handle get_handle(id_type id);
   
           static void destroy_mesh(id_type id);
       };
   }

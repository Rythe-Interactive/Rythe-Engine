
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_filesystem_view.hpp:

Program Listing for File view.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_filesystem_view.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/filesystem/view.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <core/common/result.hpp>
   #include <core/filesystem/resource.hpp>
   
   #include <core/common/exception.hpp>
   
   #include "mem_filesystem_resolver.hpp"
   #include "navigator.hpp"
   #include "detail/traits.hpp"
   
   namespace legion::core::filesystem
   {
       class view
       {
       public:
   
           //behold the noise that is copy and move operations
           view(const view& other) = default;
           view(view&& other) noexcept = default;
           view& operator=(const view& other) = default;
           view& operator=(view&& other) noexcept = default;
           virtual ~view() = default;
   
           view(std::string_view path) : m_path(strpath_manip::localize(std::string(path))) {}
   
           L_NODISCARD operator bool() const;
   
           L_NODISCARD bool is_valid( bool deep_check = false) const;
   
           L_NODISCARD file_traits file_info() const;
   
           L_NODISCARD filesystem_traits filesystem_info() const;
   
           L_NODISCARD std::string get_domain() const;
   
           L_NODISCARD const std::string& get_virtual_path() const;
   
           L_NODISCARD common::result_decay_more<std::string, fs_error> get_extension() const;
   
           L_NODISCARD common::result_decay_more<std::string, fs_error> get_filename() const;
   
           L_NODISCARD common::result_decay_more<std::string, fs_error> get_filestem() const;
   
           L_NODISCARD common::result_decay_more<basic_resource,fs_error> get();
           L_NODISCARD common::result_decay_more<const basic_resource,fs_error> get() const;
   
   
           L_NODISCARD common::result<void,fs_error> set(const basic_resource& resource);
   
           L_NODISCARD view parent() const;
   
           L_NODISCARD virtual view find(std::string_view identifier) const;
   
   
           L_NODISCARD view operator[](std::string_view identifier) const;
   
           template <class T,class... Args>
           auto load_as(Args&&...args) -> decltype(auto)
           {
               return get().decay().to<T>(std::forward<Args>(args)...);
           }
   
   
   #if  !defined( LEGION_DISABLE_POTENTIALLY_WEIRD_SYNTAX )
   
           L_NODISCARD view operator/(std::string_view identifier) const
           {
               return operator[](identifier);
           }
   
   #endif
   
       protected:
           view() = default;
           std::string m_path;
   
           std::string create_identifier(const navigator::solution::iterator&) const;
           std::shared_ptr<filesystem_resolver> build() const;
   
           struct create_chain
           {
               std::shared_ptr<mem_filesystem_resolver> subject; // subject to be resolved
               std::shared_ptr<filesystem_resolver> provider;    // resolver to be used to resolve
   
               std::shared_ptr<create_chain> next; //next in chain
           };
   
           void make_inheritance() const;
           std::shared_ptr<create_chain> translate_solution() const;
   
   
           common::result<void,fs_error> make_solution() const;
   
           mutable navigator::solution m_foundSolution{};
       };
   
   
       namespace literals
       {
          inline view operator""_view(const char* str,std::size_t len)
          {
              return view(std::string_view(str,len));
          }
       }
   
   
   #if 0 //not ready yet
   
       template <std::size_t S>
       class combined_view
       {
       public:
   
           template <class... Views,
                     typename = std::enable_if_t<(std::is_base_of_v<view,std::remove_reference<Views>> &&...)>>
           combined_view(Views&&...v) : m_views({std::forward<Views>(v)...}) {}
   
           view find(std::string_view identifier);
   
       private:
           std::array<view&,S> m_views;
       };
   
       template<class... Views>
       combined_view(Views...) -> combined_view<sizeof...(Views)>;
   
       template <std::size_t S>
       view combined_view<S>::find(std::string_view identifier)
       {
       }
   #endif
   }
   


.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_ecs_queryregistry.hpp:

Program Listing for File queryregistry.hpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_ecs_queryregistry.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/ecs/queryregistry.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/async/async.hpp>
   #include <core/containers/containers.hpp>
   #include <core/types/primitives.hpp>
   #include <core/ecs/entityquery.hpp>
   #include <core/ecs/archetype.hpp>
   #include <core/ecs/component_container.hpp>
   #include <core/time/clock.hpp>
   
   namespace legion::core::ecs
   {
       class EcsRegistry;
       class entity_handle;
   
       using entity_set = hashed_sparse_set<entity_handle>;
       using entity_container = std::vector<entity_handle>;
   
       class QueryRegistry
       {
           friend class EntityQuery;
       private:
           EcsRegistry& m_registry;
   
           mutable async::rw_spinlock m_entityLock;
           sparse_map<id_type, std::pair<float, entity_set>> m_entityLists;
   
           static thread_local std::unordered_map<id_type, std::pair<float, entity_container>> m_localCopies;
           static thread_local std::unordered_map<id_type, std::unordered_map<id_type, std::unique_ptr<component_container_base>>> m_localComponents;
           static time::clock<fast_time> m_clock;
   
           mutable async::rw_spinlock m_referenceLock;
           sparse_map<id_type, size_type> m_references;
   
           mutable async::rw_spinlock m_componentLock;
           sparse_map<id_type, hashed_sparse_set<id_type>> m_componentTypes;
   
           id_type m_lastQueryId = 1;
   
           static hashed_sparse_set<QueryRegistry*> m_validRegistries;
   
           id_type addQuery(const hashed_sparse_set<id_type>& componentTypes);
   
       public:
           static bool isValid(QueryRegistry* reg) { return m_validRegistries.contains(reg); }
   
           QueryRegistry(EcsRegistry& registry) : m_registry(registry), m_entityLists(), m_componentTypes() { m_validRegistries.insert(this); }
   
           ~QueryRegistry()
           {
               m_validRegistries.erase(this);
           }
   
           void addComponentType(id_type queryId, id_type componentTypeId);
   
           void removeComponentType(id_type queryId, id_type componentTypeId);
   
           void evaluateEntityChange(id_type entityId, id_type componentTypeId, bool removal);
   
           void markEntityDestruction(id_type entityId);
   
           id_type getQueryId(const hashed_sparse_set<id_type>& componentTypes);
   
           template<typename... component_types>
           EntityQuery createQuery()
           {
               hashed_sparse_set<id_type> componentTypeIds;
               (createQuerySingle<component_types>(componentTypeIds), ...);
               return createQuery(componentTypeIds);
           }
       private:
           template <typename T>
           void createQuerySingle(hashed_sparse_set<id_type>& h)
           {
               if constexpr (std::is_base_of_v<archetype_base,std::remove_all_extents_t<std::decay_t<T>>>)
               {
                   createQueryArchetype<T>(h,std::make_index_sequence<std::tuple_size<typename T::handleGroup>::value>{});
               } else
               {
                   h.insert(typeHash<T>());
               }
           }
   
           template <typename T,size_t ... I>
           void createQueryArchetype(hashed_sparse_set<id_type>& h,std::index_sequence<I...>)
           {
               (h.insert(typeHash<typename ch_yield_type<std::tuple_element_t<I,typename T::handleGroup>>::type>()),...);
           }
   
       public:
           EntityQuery createQuery(const hashed_sparse_set<id_type>& componentTypes);
   
           const hashed_sparse_set<id_type>& getComponentTypes(id_type queryId);
   
           const entity_container& getEntities(id_type queryId);
   
           component_container_base& getComponents(id_type queryId, id_type componentTypeId);
           void submit(id_type queryId, id_type componentTypeId);
   
           void addReference(id_type queryId);
   
           void removeReference(id_type queryId);
   
           size_type getReferenceCount(id_type queryId);
       };
   
   }

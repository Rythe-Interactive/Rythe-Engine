
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_containers_sparse_set.hpp:

Program Listing for File sparse_set.hpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_containers_sparse_set.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/containers/sparse_set.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <vector>
   #include <type_traits>
   #include <algorithm>
   #include <stdexcept>
   #include <core/platform/platform.hpp>
   #include <core/types/primitives.hpp>
   
   namespace args::core
   {
       template <typename value_type, template<typename...> typename dense_type = std::vector, template<typename...> typename sparse_type = std::vector>
       class sparse_set
       {
           static_assert(std::is_unsigned_v<value_type>, "atomic_type must an unsigned type.");
       public:
           using sparse_container = sparse_type<value_type>;
           using dense_container = dense_type<value_type>;
   
           using reference = value_type&;
           using const_reference = const value_type&;
   
           using iterator = typename dense_container::iterator;
           using const_iterator = typename dense_container::const_iterator;
   
       private:
           dense_container m_dense;
           sparse_container m_sparse;
   
           size_type m_size = 0;
           size_type m_capacity = 0;
   
       public:
           A_NODISCARD iterator begin() { return m_dense.begin(); }
           A_NODISCARD const_iterator begin() const { return m_dense.cbegin(); }
           A_NODISCARD const_iterator cbegin() const { return m_dense.cbegin(); }
   
           A_NODISCARD iterator end() { return m_dense.begin() + m_size; }
           A_NODISCARD const_iterator end() const { return m_dense.cbegin() + m_size; }
           A_NODISCARD const_iterator cend() const { return m_dense.cbegin() + m_size; }
   
           A_NODISCARD size_type size() const noexcept { return m_size; }
   
           A_NODISCARD size_type capacity() const noexcept { return m_capacity; }
   
           A_NODISCARD size_type max_size() const noexcept { return m_dense.max_size(); }
   
           A_NODISCARD bool empty() const noexcept { return m_size == 0; }
   
           void clear() noexcept { m_size = 0; }
   
           void reserve(size_type size)
           {
               if (size > m_capacity)
               {
                   m_dense.resize(size, 0);
                   m_sparse.resize(size, 0);
                   m_capacity = size;
               }
           }
   
   #pragma region count
   
           A_NODISCARD size_type count(const_reference val) const
           {
               return contains(val);
           }
   
           A_NODISCARD size_type count(value_type&& val) const
           {
               return contains(val);
           }
   #pragma endregion
   
   #pragma region contains
   
           A_NODISCARD bool contains(const_reference val) const
           {
               return val < m_capacity&&
                   m_sparse[val] < m_size&&
                   m_dense[m_sparse[val]] == val;
           }
   
           A_NODISCARD bool contains(value_type&& val) const
           {
               return val < m_capacity&&
                   m_sparse[val] < m_size&&
                   m_dense[m_sparse[val]] == val;
           }
   
           A_NODISCARD bool contains(const sparse_set<value_type>& other) const
           {
               if (other.m_size == 0)
                   return true;
   
               if (m_size == 0 || m_size < other.m_size)
                   return false;
   
               for (const_reference item : other)
                   if (contains(item))
                       return false;
   
               return true;
           }
   #pragma endregion
   
           A_NODISCARD bool equals(const sparse_set<value_type>& other) const
           {
               if (m_size == other.m_size)
               {
                   for (int i = 0; i < m_size; i++)
                       if (!other.contains(m_dense[i]))
                           return false;
   
                   return true;
               }
   
               return false;
           }
   
           A_NODISCARD bool operator==(const sparse_set<value_type>& other) const
           {
               if (m_size == other.m_size)
               {
                   for (int i = 0; i < m_size; i++)
                       if (!other.contains(m_dense[i]))
                           return false;
   
                   return true;
               }
   
               return false;
           }
   
   #pragma region find
   
           A_NODISCARD iterator find(const_reference val)
           {
               if (contains(val))
                   return begin() + m_sparse[val];
               return end();
           }
   
           A_NODISCARD const_iterator find(const_reference val) const
           {
               if (contains(val))
                   return begin() + m_sparse[val];
               return end();
           }
   #pragma endregion
   
   #pragma region insert
   
           std::pair<iterator, bool> insert(const_reference val)
           {
               if (!contains(val))
               {
                   if (val >= m_capacity)
                       reserve(val + 1);
   
                   auto itr = m_dense.begin() + m_size;
                   *itr = val;
                   m_sparse[val] = (value_type)m_size;
                   ++m_size;
                   return std::make_pair(itr, true);
               }
               return std::make_pair(m_dense.end(), false);
           }
   
           std::pair<iterator, bool> insert(value_type&& val)
           {
               if (!contains(val))
               {
                   if (val >= m_capacity)
                       reserve(val + 1);
   
                   auto itr = m_dense.begin() + m_size;
                   *itr = std::move(val);
                   m_sparse[*itr] = (value_type)m_size;
                   ++m_size;
                   return std::make_pair(itr, true);
               }
               return std::make_pair(m_dense.end(), false);
           }
   #pragma endregion
   
   #pragma region operator[]
   
           A_NODISCARD reference operator[](size_type&& index)
           {
               if (index < 0 || index > m_size)
                   throw std::out_of_range("sparse_set subscript out of range");
               return m_dense[index];
           }
   
           A_NODISCARD reference operator[](const size_type& index)
           {
               if (index < 0 || index > m_size)
                   throw std::out_of_range("sparse_set subscript out of range");
               return m_dense[index];
           }
   
           A_NODISCARD const_reference operator[](size_type&& index) const
           {
               if (index < 0 || index > m_size)
                   throw std::out_of_range("sparse_set subscript out of range");
               return m_dense[index];
           }
   
           A_NODISCARD const_reference operator[](const size_type& index) const
           {
               if (index < 0 || index > m_size)
                   throw std::out_of_range("sparse_set subscript out of range");
               return m_dense[index];
           }
   #pragma endregion
   
           size_type erase(const_reference val)
           {
               if (contains(val))
               {
                   m_dense[m_sparse[val]] = m_dense[m_size - 1];
                   m_sparse[m_dense[m_size - 1]] = m_sparse[val];
                   --m_size;
                   return true;
               }
               return false;
           }
       };
   }

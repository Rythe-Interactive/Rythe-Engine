
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_rendering_systems_renderer.hpp:

Program Listing for File renderer.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_rendering_systems_renderer.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/rendering/systems/renderer.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <rendering/pipeline/base/pipeline.hpp>
   #include <rendering/pipeline/default/defaultpipeline.hpp>
   
   #include <unordered_map>
   
   namespace legion::rendering
   {
       class Renderer final : public System<Renderer>
       {
       private:
           static delegate<RenderPipelineBase*(app::window&)> m_pipelineProvider;
           std::atomic_bool m_exiting = false;
   
           static void debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, L_MAYBEUNUSED const void* userParam);
           static void debugCallbackARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, L_MAYBEUNUSED const void* userParam);
           static void debugCallbackAMD(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, L_MAYBEUNUSED void* userParam);
           bool initContext(const app::window& window);
   
           void setThreadPriority();
   
           static RenderPipelineBase* m_currentPipeline;
   
       public:
           Renderer() : System<Renderer>()
           {
               setPipeline<DefaultPipeline>();
           }
   
           virtual void setup();
   
           void onExit(events::exit* event);
   
           void render(time::span deltatime);
   
           template<typename Pipeline, typename... Args CNDOXY(inherits_from<Pipeline, RenderPipeline<Pipeline>> = 0)>
           static void setPipeline(Args&&... args);
   
           L_NODISCARD static RenderPipelineBase* getPipeline(app::window& context);
           L_NODISCARD static RenderPipelineBase* getCurrentPipeline();
           L_NODISCARD static RenderPipelineBase* getMainPipeline();
       };
   }
   
   #include <rendering/systems/renderer.inl>

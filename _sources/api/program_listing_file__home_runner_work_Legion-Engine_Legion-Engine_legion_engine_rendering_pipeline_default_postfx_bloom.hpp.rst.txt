
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_rendering_pipeline_default_postfx_bloom.hpp:

Program Listing for File bloom.hpp
==================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_rendering_pipeline_default_postfx_bloom.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/rendering/pipeline/default/postfx/bloom.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <rendering/data/postprocessingeffect.hpp>
   
   
   namespace legion::rendering
   {
       class Bloom : public PostProcessingEffect<Bloom>
       {
       private:
           shader_handle m_brightnessThresholdShader;
           shader_handle m_gaussianBlurShader;
           shader_handle m_combineShader;
           shader_handle m_historyMixShader;
   
           framebuffer m_pingpongFrameBuffers[2];
           texture_handle m_pingpongTextureBuffers[2];
   
           texture_import_settings settings{
                 texture_type::two_dimensional,
                 channel_format::float_hdr,
                 texture_format::rgba_hdr,
                 texture_components::rgb,
                 true,
                 true,
                 texture_mipmap::linear,
                 texture_mipmap::linear,
                 texture_wrap::mirror,
                 texture_wrap::mirror,
                 texture_wrap::mirror
           };
   
       public:
           void setup(app::window& context) override;
   
           void seperateOverdraw(framebuffer& fbo, texture_handle colortexture, texture_handle overdrawtexture);
   
           texture_handle blurOverdraw(const math::ivec2& framebufferSize, texture_handle overdrawtexture);
   
           void historyMixOverdraw(framebuffer& fbo, texture_handle overdrawtexture);
   
           void combineImages(framebuffer& fbo, texture_handle colortexture, texture_handle overdrawtexture);
   
           void renderPass(framebuffer& fbo, RenderPipelineBase* pipeline, camera& cam, const camera::camera_input& camInput, time::span deltaTime);
       };
   }

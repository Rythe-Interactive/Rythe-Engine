
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_filesystem_provider_registry.hpp:

Program Listing for File provider_registry.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_filesystem_provider_registry.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/filesystem/provider_registry.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <memory>
   
   #include <string_view>
   #include <string>
   #include <unordered_map>
   #include <unordered_set>
   #include <vector>
   
   #include "detail/meta.hpp"
   #include "filesystem_resolver.hpp"
   #include "mem_filesystem_resolver.hpp"
   
   namespace legion::core::filesystem{
       class provider_registry
       {
       public:
           using domain = std::string;
           using resolver = filesystem_resolver;
           using resolver_ptr = resolver*;
           
           static std::unordered_set<domain> domains();
           static bool has_domain(domain);
   
           static void domain_add_resolver(domain, resolver_ptr);
   
           //TODO(algo-ryth-mix): removed multiple registration, use unordered_map instead of unordered_multimap 
           //TODO(algo-ryth-mix): add checking that only tl resolvers can be of the non-memory variety
           template <typename Resolver,
                     typename ... Args,
                     typename = typename std::enable_if<std::is_base_of<filesystem_resolver_common_base,Resolver>::value>::type>
           static void domain_create_resolver(domain d,Args&&... args)
           {
               OPTICK_EVENT();
               return domain_add_resolver(d,new Resolver(std::forward<Args>(args)...));
           }
   
           static std::vector<resolver_ptr> domain_get_resolvers(domain);
   
   
           //NOTICE! this interface is going to be removed, do not use it
           class resolver_sentinel
           {
               friend class provider_registry;
               domain inspected_domain;
               std::size_t index;
               static constexpr std::size_t sentinel_value = std::numeric_limits<std::size_t>::max();
   
               resolver_sentinel(std::nullptr_t) : index{sentinel_value}{}
               resolver_sentinel(size_t index, domain d) : inspected_domain(d), index(index){}
               
           public:
               resolver_sentinel operator++() const;
               resolver_sentinel operator--() const;
               resolver_ptr operator*() const;
               resolver_ptr operator->() const;
               
               friend bool operator==(const resolver_sentinel& lhs, const resolver_sentinel& rhs);
           };
   
           static resolver_sentinel domain_get_first_resolver(domain);
   
           static resolver_sentinel domain_get_prev_resolver(const resolver_sentinel& iterator);
   
           static resolver_sentinel domain_get_next_resolver(const resolver_sentinel& iterator);
   
           static resolver_sentinel domain_get_resolver_end();
   
           static resolver_ptr      domain_get_resolver_at(const resolver_sentinel& iterator);
           
   
       private:
   
           struct driver;
   
           provider_registry() = default;
           static driver& get_driver();        
       };
   }

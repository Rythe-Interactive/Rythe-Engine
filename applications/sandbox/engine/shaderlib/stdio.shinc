/////////////////////
//  Default Input  //
/////////////////////

#if !defined(STDIO_INCL)
#define STDIO_INCL
#endif

#if defined(VERTEX_SHADER)
in vec3 position : SV_POSITION;
in vec3 normal : SV_NORMAL;
in vec3 tangent : SV_TANGENT;
in vec4 vertexcolor : SV_COLOR;
in vec2 uv : SV_TEXCOORD0;
in mat4 modelMatrix : SV_MODELMATRIX;
#endif

#if defined(VERTEX_SHADER)
#define io out
#elif defined(FRAGMENT_SHADER)
#define io in
#endif

#if defined(GEOMETRY_SHADER)
in LGN_STDVTXGEOM
#elif defined(GEOMETRY_SHADER_ACTIVE)
#if defined(VERTEX_SHADER)
out LGN_STDVTXGEOM
#elif defined(FRAGMENT_SHADER)
in LGN_STDGEOMFRAG
#endif
#else
io LGN_STDIO
#endif
{
    vec3 position;
    vec3 wvertex;
    vec4 vertexcolor;
    vec3 normal;
    vec3 wnormal;
    vec3 tangent;
    vec3 wtangent;
    vec2 uv;
    mat4 modelMatrix;
}
#if defined(GEOMETRY_SHADER)
lgn_stdin[LGN_geom_vtxc];
#else
lgn_stdio;
#endif
#if defined(GEOMETRY_SHADER)
out LGN_STDGEOMFRAG
{
    vec3 position;
    vec3 wvertex;
    vec4 vertexcolor;
    vec3 normal;
    vec3 wnormal;
    vec3 tangent;
    vec3 wtangent;
    vec2 uv;
    mat4 modelMatrix;
} lgn_stdout;
#endif


#if defined(VERTEX_SHADER)
#define stdio(param) param
#define stdin(param) param
#define stdout(param) lgn_stdio.param
#elif defined(FRAGMENT_SHADER)
#define stdio(param) lgn_stdio.param
#define stdin(param) lgn_stdio.param
#elif defined(GEOMETRY_SHADER)
#define stdin(index, param) lgn_stdin[index].param
#define stdout(param) lgn_stdout.param
#endif

struct Camera
{
    mat4 viewMatrix;
    mat4 projectionMatrix;
    vec3 position;
    float farz;
    vec3 viewDirection;
    float nearz;
    #if defined(GEOMETRY_SHADER)
    vec3 toView[LGN_geom_vtxc];
    #else
    vec3 toView;
    #endif
};

struct CameraInput
{
    mat4 view;
    mat4 proj;
    vec4 posnearz;
    vec4 vdirfarz;
    ivec2 viewportSize;
};

uniform CameraInput lgn_cmr_in : SV_CAMERA;

uniform sampler2D lgn_sceneDepth : SV_SCENEDEPTH;
uniform sampler2D lgn_sceneColor : SV_SCENECOLOR;
uniform sampler2D lgn_hdrOverdraw : SV_HDROVERDRAW;

#define ViewMatrix lgn_cmr_in.view
#define ProjectionMatrix lgn_cmr_in.proj
#define ViewProjectionMatrix (lgn_cmr_in.proj * lgn_cmr_in.view)

vec4 WorldToScreenSpacePosition(vec3 pos)
{
    return (ViewProjectionMatrix * vec4(pos, 1.f));
}

vec4 WorldToScreenSpacePosition(vec4 pos)
{
    return (ViewProjectionMatrix * pos);
}

Camera GetCamera()
{
    Camera camera;
    camera.viewMatrix = lgn_cmr_in.view;
    camera.projectionMatrix = lgn_cmr_in.proj;
    camera.position = lgn_cmr_in.posnearz.xyz;
    camera.nearz = lgn_cmr_in.posnearz.w;
    camera.viewDirection = lgn_cmr_in.vdirfarz.xyz;
    camera.farz = lgn_cmr_in.vdirfarz.w;
    #if defined(VERTEX_SHADER)
    camera.toView = camera.position - (modelMatrix * vec4(position, 1.0)).xyz;
    #elif defined(FRAGMENT_SHADER)
    camera.toView = camera.position - lgn_stdio.wvertex;
    #elif defined(GEOMETRY_SHADER)
    for(int i = 0; i < LGN_geom_vtxc; i++)
        camera.toView[i] = camera.position - lgn_stdin[i].wvertex;
    #endif
    return camera;
}

float FrustumDepth()
{
    return lgn_cmr_in.vdirfarz.w - lgn_cmr_in.posnearz.w;
}

vec4 ModelToScreenSpacePosition(vec3 pos)
{
    #if defined(GEOMETRY_SHADER)
    return (ViewProjectionMatrix * stdin(0, modelMatrix)) * vec4(pos, 1.f);
    #else
    return (ViewProjectionMatrix * stdio(modelMatrix)) * vec4(pos, 1.f);
    #endif
}

vec3 SceneColor(vec2 uv)
{
    return texture(lgn_sceneColor, uv).rgb;
}

vec3 SceneDepth(vec2 uv)
{
    return texture(lgn_sceneDepth, uv).rgb;
}

float LinearDepth(float depth)
{
    return lgn_cmr_in.posnearz.w * lgn_cmr_in.vdirfarz.w / (lgn_cmr_in.vdirfarz.w + depth * (lgn_cmr_in.posnearz.w - lgn_cmr_in.vdirfarz.w));
}

#if defined(FRAGMENT_SHADER)

#define SV_FRAGMENTOUT 0
#define SV_HDROVERDRAWOUT 1

#if !defined(NO_DEFAULT_OUT)
out vec4 fragment_color : SV_FRAGMENTOUT;
#endif

#if !defined(NO_DEPTH_OUT)
out float gl_FragDepth;

#define fragment_depth gl_FragDepth
#endif

in vec4 gl_FragCoord;

vec2 ScreenUV()
{
    return gl_FragCoord.xy / lgn_cmr_in.viewportSize;
}

vec3 SceneColor()
{
    return texture(lgn_sceneColor, gl_FragCoord.xy / lgn_cmr_in.viewportSize).rgb;
}

vec3 SceneDepth()
{
    return texture(lgn_sceneDepth, gl_FragCoord.xy / lgn_cmr_in.viewportSize).rgb;
}

float LinearDepth()
{
       return lgn_cmr_in.posnearz.w * lgn_cmr_in.vdirfarz.w / (lgn_cmr_in.vdirfarz.w - gl_FragCoord.z * (lgn_cmr_in.posnearz.w - lgn_cmr_in.vdirfarz.w));
}

bool DepthCull(float depth)
{
    #if defined(DEPTH_ONLY)
    return true;
    #else
    //return LinearDepth() <= LinearDepth(depth) + 0.0001;
    return false;
    #endif
}
#endif

#if defined(GEOMETRY_SHADER)  // Geometry shader
vec3 GetWorldPosition(int index)
{
    return normalize(stdin(index, wvertex));
}

vec3 GetWorldNormal(int index)
{
    return normalize(stdin(index, wnormal));
}

vec3 GetWorldTangent(int index)
{
    vec3 worldNormal = GetWorldNormal(index);
    return normalize(stdin(index, wtangent) - dot(stdin(index, wtangent), worldNormal) * worldNormal);
}

vec3 GetWorldTangent(int index, vec3 worldNormal)
{
    return normalize(stdin(index, wtangent) - dot(stdin(index, wtangent), worldNormal) * worldNormal);
}

vec3 GetWorldBitangent(int index)
{
    vec3 worldNormal = GetWorldNormal(index);
	vec3 worldTangent = GetWorldTangent(index, worldNormal);
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldBitangent(int index, vec3 worldNormal)
{
	vec3 worldTangent = GetWorldTangent(index, worldNormal);
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldBitangent(vec3 worldNormal, vec3 worldTangent)
{
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldDirection(vec3 dir)
{
    return normalize((stdin(0, modelMatrix) * vec4(dir, 0.0)).xyz);
}

vec3 GetWorldPoint(vec3 p)
{
    return (stdin(0, modelMatrix) * vec4(p, 1.0)).xyz;
}

mat3 GetTBNMatrix(int index)
{
    vec3 worldNormal = GetWorldNormal(index);
	vec3 worldTangent = GetWorldTangent(index, worldNormal);
	vec3 worldBitangent = GetWorldBitangent(worldNormal, worldTangent);
	return transpose(mat3(worldTangent, worldBitangent, worldNormal));
}

mat3 GetTBNMatrix(vec3 worldNormal, vec3 worldTangent)
{
    vec3 orthogonalizedTangent = normalize(worldTangent - dot(worldTangent, worldNormal) * worldNormal);
	vec3 worldBitangent = GetWorldBitangent(worldNormal, orthogonalizedTangent);
	return transpose(mat3(orthogonalizedTangent, worldBitangent, worldNormal));
}

#else // Not geometry shader
vec3 GetWorldPosition()
{
#if defined(FRAGMENT_SHADER)
    return lgn_stdio.wvertex;
#elif defined(VERTEX_SHADER)
    return (stdio(modelMatrix) * vec4(stdio(position), 1.0)).xyz;
#endif
}

vec3 GetWorldNormal()
{
#if defined(FRAGMENT_SHADER)
    return normalize(lgn_stdio.wnormal);
#elif defined(VERTEX_SHADER)
    return normalize((stdio(modelMatrix) * vec4(stdio(normal), 0.0)).xyz);
#endif
}

vec3 GetWorldTangent()
{
    vec3 worldNormal = GetWorldNormal();
#if defined(FRAGMENT_SHADER)
    return normalize(lgn_stdio.wtangent - dot(lgn_stdio.wtangent, worldNormal) *worldNormal);
#elif defined(VERTEX_SHADER)
    vec3 worldTangent = normalize((stdio(modelMatrix) * vec4(tangent, 0.0)).xyz);
    return normalize(worldTangent - dot(worldTangent, worldNormal) * worldNormal);
#endif
}

vec3 GetWorldTangent(vec3 worldNormal)
{
#if defined(FRAGMENT_SHADER)
    return normalize(lgn_stdio.wtangent - dot(lgn_stdio.wtangent, worldNormal) *worldNormal);
#elif defined(VERTEX_SHADER)
    vec3 worldTangent = normalize((stdio(modelMatrix) * vec4(tangent, 0.0)).xyz);
    return normalize(worldTangent - dot(worldTangent, worldNormal) * worldNormal);
#endif
}

vec3 GetWorldBitangent()
{
    vec3 worldNormal = GetWorldNormal();
	vec3 worldTangent = GetWorldTangent(worldNormal);
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldBitangent(vec3 worldNormal)
{
	vec3 worldTangent = GetWorldTangent(worldNormal);
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldBitangent(vec3 worldNormal, vec3 worldTangent)
{
	return normalize(cross(worldNormal, worldTangent));
}

vec3 GetWorldDirection(vec3 dir)
{
    return normalize((stdio(modelMatrix) * vec4(dir, 0.0)).xyz);
}

vec3 GetWorldPoint(vec3 p)
{
    return (stdio(modelMatrix) * vec4(p, 1.0)).xyz;
}

mat3 GetTBNMatrix()
{
    vec3 worldNormal = GetWorldNormal();
	vec3 worldTangent = GetWorldTangent(worldNormal);
	vec3 worldBitangent = GetWorldBitangent(worldNormal, worldTangent);
	return transpose(mat3(worldTangent, worldBitangent, worldNormal));
}

mat3 GetTBNMatrix(vec3 worldNormal, vec3 worldTangent)
{
    vec3 orthogonalizedTangent = normalize(worldTangent - dot(worldTangent, worldNormal) * worldNormal);
	vec3 worldBitangent = GetWorldBitangent(worldNormal, orthogonalizedTangent);
	return transpose(mat3(orthogonalizedTangent, worldBitangent, worldNormal));
}
#endif // End not geometry shader

#if defined(VERTEX_SHADER)
void PropagateStdIO()
{
    lgn_stdio.position = position;
    lgn_stdio.wvertex = GetWorldPosition();
    lgn_stdio.vertexcolor = vertexcolor;
    lgn_stdio.normal = normal;
    lgn_stdio.wnormal = GetWorldNormal();
    lgn_stdio.tangent = tangent;
    lgn_stdio.wtangent = GetWorldTangent(lgn_stdio.wnormal);
    lgn_stdio.uv = uv;
    lgn_stdio.modelMatrix = modelMatrix;
}
#elif defined(GEOMETRY_SHADER)
void PropagateStdIO(int index)
{
    stdout(position) = stdin(index, position);
    stdout(wvertex) = stdin(index, wvertex);
    stdout(vertexcolor) = stdin(index, vertexcolor);
    stdout(normal) = stdin(index, normal);
    stdout(wnormal) = stdin(index, wnormal);
    stdout(tangent) = stdin(index, tangent);
    stdout(wnormal) = stdin(index, wnormal);
    stdout(uv) = stdin(index, uv);
    stdout(modelMatrix) = stdin(index, modelMatrix);
}
#endif
